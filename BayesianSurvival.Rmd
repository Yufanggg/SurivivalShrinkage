---
title: "BayesianSurvival"
author: "Yufang"
date: "2025-02-19"
output: pdf_document
---

# STEP 1. load packages
```{r, echo=TRUE}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
library(survival)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
```

# STEP 2. predefine a design matrix with one column 
```{r, echo=TRUE}
n_samples = 1000
Betas = 1
Design_matrix = as.matrix(rbinom(n_samples, 1, prob = 0.5)) #rnorm(n_samples))
BaselinePara = c(0.1, 0.2)


stan_data = SurvivalDataGenerator(n_samples, Betas, Design_matrix, 
                                  BaselinePara, BaselineDistr = "exponential") # exponential, weibull, and Gompertz

# use the traditional coxph to verify that the data was correctly generated
coxph(Surv(stan_data$obstime, stan_data$status) ~ stan_data$covariate)
```
## Conclusion for STEP 2: the betas are correctly estimated via traditional cox regression, meaning that data was correctly generated.

# STEP 3. Proportional Hazard (PH) Model with covariates via partial likelihood function
```{r, echo=TRUE}
code_bayesian_PH_model <- "
  data { 
    int <lower=0> K; //num covariates
    int <lower=0> N; // num uncensored obs
    
    vector[N] t; // event time (non-strict decreasing)
    matrix[N, K] x; // covariates for uncensored obs
    
    int N_cens; // num censored obs
    vector[N_cens] t_cens; // censoring time
    matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    vector[K] beta; // slopes without intercept
  }
  model {
    beta ~ normal(0, 2); // prior
    vector[N] log_theta = x * beta;
    vector [N_cens] log_theta_c = x_cens * beta;
    real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
    target += log_theta - log_denom;
    
  }
"

# compile the model
bayesian_PH_model <- stan_model(model_name = "bayesian_PH_model", 
                                         model_code = code_bayesian_PH_model)

# Step 3: Model fitting and summary
niter = 10000; nwarmup = 1000 
bayesian_PH_model_fit <- suppressWarnings(sampling(bayesian_PH_model, data = stan_data, iter = niter, 
                                    warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(bayesian_PH_model_fit)$summary)
```
## Conclusion for STEP 3: the betas are correctly estimated via bayesian cox regression, meaning that bayesian cox regression was correctly defined.



# 6. Accelerated failure time (AFT) model with covariates
```{r, echo=TRUE}
# Step 1: simulated data generator

# Step 2: Bayesian model setting & compiling

# Step 3: Model fitting and summary
```

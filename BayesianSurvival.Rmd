---
title: "BayesianSurvival"
author: "Yufang"
date: "2025-02-19"
output: pdf_document
---

# 1. load packages
```{r, echo=TRUE}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
# Set seed for reproducibility
set.seed(42)
```

# 2. Start with Bayesian regression: alpha_true: 2.0, beta_true: 3.0, sigma_true: 1.0
```{r, echo=TRUE}
Bayesian_regression <- "
data {
  int<lower=0> N;
  vector[N] x;
  vector[N] y;
  }
parameters {
  real alpha;
  real beta;
  real <lower=0> sigma;
}
model {
  y ~ normal(alpha + beta * x, sigma);
} "


# Compile the Stan model
stan_model <- stan_model(model_code = Bayesian_regression)


# Generated simulated data for running models
## Number of observations
N <- 100
## Generate random covariate data
x <- rnorm(N, mean = 0, sd = 1)
## Define true parameters
alpha_true <- 2.0
beta_true <- 3.0
sigma_true <- 1.0
## Generate response variable data with some noise
y <- alpha_true + beta_true * x + rnorm(N, mean = 0, sd = sigma_true)
## Create a list to store the generated data
stan_data <- list(
  N = N,
  x = x,
  y = y
)
## Run the sampling
fit <- sampling(stan_model, data = stan_data, iter = 2000, warmup = 500, chains = 4, thin = 1)
## Print the results
print(fit)
print(summary(fit)$summary)
```

# 3. build up no-covariate survival models
```{r, echo=TRUE}
# set the bayesian survival model
# simple survival analysis without covariates

## The exponential survival model and the prior are coded directly using vectorized distribution and ccdf statements. 
# The likelihood for rate lambda is just the density of exponential distribution for observed failure time. 
code_bayesian_survival_0 <- "
  data { 
    int<lower=0> N; // the number of uncensored observations
    vector[N] t; // the times of the uncensored observations
    int<lower=0> N_cens; // the number of censored items that are right censored at time t_cens
    real<lower=0> t_cens; // it is only observed that the part survived until time t_cens.
  }
  parameters {
    real<lower=0> lambda;
    
    
  }
  model {
    t ~ exponential(lambda);
    target += N_cens * exponential_lccdf(t_cens | lambda);
    lambda ~ lognormal(0, 1); 
  }
"

# compile the model

pmt <- proc.time()
bayesian_survival_0 <- stan_model(model_name = "bayesian_survival_0", 
                                         model_code = code_bayesian_survival_0)
proc.time()-pmt


# get a simulated dataset & prepare it for stan

# Load necessary libraries
library(dplyr)

# Parameters for the simulation
N <- 100  # Number of observations
lambda_true <- 0.1  # True rate parameter for the exponential distribution
censoring_time <- 12  # Censoring time

# Simulate survival times from an exponential distribution
survival_times <- rexp(N, rate = lambda_true)

# Simulate censoring indicator (1 if censored, 0 if not)
censored <- survival_times > censoring_time
observed_times <- ifelse(censored, censoring_time, survival_times)

# Create a data frame to store the simulated data
simulated_data <- data.frame(
  observed_times = observed_times,
  censored = as.integer(censored)
)

## prepare the simulated data for stan
stan_data <- list(
  N = nrow(simulated_data),
  t = simulated_data$observed_times,
  N_cens = sum(simulated_data$censored),
  t_cens = 12 # Censoring time used in the simulation
)
```

# 3.1 fit the model on the data
```{r, echo=TRUE}

#' Sampling from the model
niter = 10000; nwarmup = 1000 
Bayint <- suppressWarnings(sampling(bayesian_survival_0, data = stan_data, iter = niter, 
                                    warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(Bayint)$summary)
```

# 4. build up survival models with covariates
```{r, echo=TRUE}
# Step 1: simulated data generator
# Number of observations
N <- 100
N_cens <- 20
# Define true parameters
beta_true <- c(0.5, 1, 0.8)
censoring_time <- 10 # Censoring time
K <- 3

# Generate random covariate data
x_all <- matrix(rnorm(N * K), N, K)

# Simulate survival times from an exponential distribution
survival_times <- rexp(N, rate = exp(x_all %*% beta_true))

# Simulate censoring indicator (1 if censored, 0 if not)
censored <- survival_times > censoring_time
observed_times <- ifelse(censored, censoring_time, survival_times)

# Create a data frame to store the simulated data
simulated_data <- data.frame(
  observed_times = observed_times,
  censored = as.integer(censored)
)

stan_data <- list(
  N = nrow(simulated_data),
  t = simulated_data$observed_times,
  N_cens = sum(simulated_data$censored),
  t_cens = censoring_time, # Censoring time used in the simulation,
  
  K = K,# the number of columns in the design matrix, i.e., coefficients
  x = x_all,#;
  x_cens = x_all[censored==1,]
)


# Step 2: model setting and compiling
code_bayesian_survival_withCovariate <- "
  data { 
    int<lower=0> N; // the number of uncensored observations
    vector[N] t; // the times of the uncensored observations
    int<lower=0> N_cens; // the number of censored items that are right censored at time t_cens
    real<lower=0> t_cens; // it is only observed that the part survived until time t_cens.
    
    int<lower=0> K; // the number of columns in the design matrix, i.e., coefficients
    matrix[N, K] x;
    matrix[N_cens, K] x_cens;
  }
  parameters {
    vector[K] beta;
  }
  model {
    beta ~ normal(0, 2);
    t ~ exponential(exp(x * beta));
    target += N_cens *exponential_lccdf(t_cens | exp(x_cens * beta));
  }
"

# compile the model
bayesian_survival_withCovariate <- stan_model(model_name = "bayesian_survival_withCovariate", 
                                         model_code = code_bayesian_survival_withCovariate)
# Step 3: model fitting and output
niter = 10000; nwarmup = 1000 
Bayint_survival_withCovariate <- suppressWarnings(sampling(bayesian_survival_withCovariate, data = stan_data, iter = niter, 
                                    warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(Bayint_survival_withCovariate)$summary)
```

---
title: "BayesianSurvival"
author: "Yufang"
date: "2025-02-19"
output: pdf_document
---

# 1. load packages
```{r, echo=TRUE}
rm(list = ls())
# install.packages("rstan")
# install.packages("readr")
library(rstan)
library(readr)
# Set seed for reproducibility
set.seed(42)
source("./SurvivalDataGenerator.R")
```

# 2. Start with Bayesian regression: alpha_true: 2.0, beta_true: 3.0, sigma_true: 1.0
```{r, echo=TRUE}
Bayesian_regression <- "
data {
  int<lower=0> N;
  vector[N] x;
  vector[N] y;
  }
parameters {
  real alpha;
  real beta;
  real <lower=0> sigma;
}
model {
  y ~ normal(alpha + beta * x, sigma);
} "


# Compile the Stan model
stan_model <- stan_model(model_code = Bayesian_regression)


# Generated simulated data for running models
## Number of observations
N <- 100
## Generate random covariate data
x <- rnorm(N, mean = 0, sd = 1)
## Define true parameters
alpha_true <- 2.0
beta_true <- 3.0
sigma_true <- 1.0
## Generate response variable data with some noise
y <- alpha_true + beta_true * x + rnorm(N, mean = 0, sd = sigma_true)
## Create a list to store the generated data
stan_data <- list(
  N = N,
  x = x,
  y = y
)
## Run the sampling
fit <- sampling(stan_model, data = stan_data, iter = 2000, warmup = 500, chains = 4, thin = 1)
## Print the results
print(fit)
print(summary(fit)$summary)

summary(lm(y~x))
```

# 3. build up no-covariate survival models
```{r, echo=TRUE}
## Step 1: get the simulated data
stan_data = SurvivalDataGenerator(1000)

## Step 2: set up and compile the bayesian model
# set the bayesian survival model
# simple survival analysis without covariates

## The exponential survival model and the prior are coded directly using vectorized distribution and ccdf statements. 
# The likelihood for rate lambda is just the density of exponential distribution for observed failure time. 
code_bayesian_survival_0 <- "
  data { 
    int<lower=0> N; // the number of uncensored observations
    vector[N] t; // the times of the uncensored observations
    int<lower=0> N_cens; // the number of censored items that are right censored at time t_cens
    vector[N_cens] t_cens; // it is only observed that the part survived until time t_cens.
  }
  parameters {
    real<lower=0> lambda;
    
    
  }
  model {
    lambda ~ lognormal(0, 1); // prior
    t ~ exponential(lambda); //
    target += N_cens * exponential_lccdf(t_cens | lambda); //exponential_lccdf computes the log of the complementary cumulatve distribution for the exponential dirtibution, i.e., survival function P(X > t_cens)
  }
"

# compile the model

pmt <- proc.time()
bayesian_survival_0 <- stan_model(model_name = "bayesian_survival_0", 
                                         model_code = code_bayesian_survival_0)
proc.time()-pmt

## Step 3: fit the model & give the model

#' Sampling from the model
niter = 10000; nwarmup = 1000 
Bayint <- suppressWarnings(sampling(bayesian_survival_0, data = stan_data, iter = niter, 
                                    warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(Bayint)$summary)
```

# 4. build up survival models with binary covariates
```{r, echo=TRUE}
## Step 1: simulated data generator
stan_data2 = SurvivalDataGenerator(1000, anycovariate = "binary", beta = 0.3)

## Step 2: use the traditional 
coxph(Surv(stan_data2$obstime, stan_data2$status) ~ stan_data2$covariate)
# Step 2: model setting and compiling
code_bayesian_survival_withCovariate <- "
  data { 
    int<lower=0> N; // the number of uncensored observations
    vector[N] t; // the times of the uncensored observations
    int<lower=0> N_cens; // the number of censored items that are right censored at time t_cens
    vector[N_cens] t_cens; // it is only observed that the part survived until time t_cens.
    
    int<lower=0> K; // the number of columns in the design matrix, i.e., coefficients
    matrix[N, K] x;
    matrix[N_cens, K] x_cens;
  }
  parameters {
    vector[K] beta;
  }
  model {
    beta ~ normal(0, 2);
    t ~ exponential(exp(x * beta));
    target += exponential_lccdf(t_cens | exp(x_cens * beta));
  }
"

# compile the model
bayesian_survival_withCovariate <- stan_model(model_name = "bayesian_survival_withCovariate", 
                                         model_code = code_bayesian_survival_withCovariate)
# Step 3: model fitting and output
niter = 10000; nwarmup = 1000 
Bayint_survival_withCovariate <- suppressWarnings(sampling(bayesian_survival_withCovariate, data = stan_data2, iter = niter, warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(Bayint_survival_withCovariate)$summary)
```
# 5. build up survival models with continuous covariates
```{r, echo=TRUE}
## Step 1: simulated data generator
stan_data3 = SurvivalDataGenerator(1000, anycovariate = "continuous", beta = 0.3)

## Step 2: use the traditional coxph regression to validate the data simulation
coxph(Surv(stan_data3$obstime, stan_data3$status) ~ stan_data3$covariate)
# Step 2: model setting and compiling
code_bayesian_survival_withCCovariate <- "
  data { 
    int<lower=0> N; // the number of uncensored observations
    vector[N] t; // the times of the uncensored observations
    int<lower=0> N_cens; // the number of censored items that are right censored at time t_cens
    vector[N_cens] t_cens; // it is only observed that the part survived until time t_cens.
    
    int<lower=0> K; // the number of columns in the design matrix, i.e., coefficients
    matrix[N, K] x;
    matrix[N_cens, K] x_cens;
  }
  parameters {
    vector[K] beta;
  }
  model {
    beta ~ normal(0, 2);
    t ~ exponential(exp(x * beta));
    target += exponential_lccdf(t_cens | exp(x_cens * beta));
  }
"

# compile the model
bayesian_survival_withCCovariate <- stan_model(model_name = "bayesian_survival_withCCovariate", 
                                         model_code = code_bayesian_survival_withCCovariate)
# Step 3: model fitting and output
niter = 10000; nwarmup = 1000 
Bayint_survival_withCCovariate <- suppressWarnings(sampling(bayesian_survival_withCCovariate, data = stan_data3, iter = niter, warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(Bayint_survival_withCCovariate)$summary)
```

# 5. Proportional Hazard (PH) Model

## 5.1 PH model with covariates via partial likelihood function
```{r, echo=TRUE}
# Step 1: simulated data generator
stan_data4 = SurvivalDataGenerator(1000, distribution = "exponential_", anycovariate = "continuous", beta = 0.3)

# Step 2: use traditional coxph regression to validate that data is well generated
coxph(Surv(stan_data4$obstime, stan_data4$status) ~ stan_data4$covariate)

# Step 3: Bayesian model setting & compiling
code_bayesian_PH_model <- "
  data { 
    int <lower=0> K; //num covariates
    int <lower=0> N; // num uncensored obs
    
    vector[N] t; // event time (non-strict decreasing)
    matrix[N, K] x; // covariates for uncensored obs
    
    int N_cens; // num censored obs
    vector[N_cens] t_cens; // censoring time
    matrix[N_cens, K] x_cens; // covariates for censored obs
  }
  parameters {
    vector[K] beta; // slopes without intercept
  }
  model {
    beta ~ normal(0, 2); // prior
    vector[N] log_theta = x * beta;
    vector [N_cens] log_theta_c = x_cens * beta;
    real log_denom = log_sum_exp(log_theta_c); //log_sum_exp is defined as the logarithm of the sum of exponentials of the input values
    target += log_theta - log_denom;
    
  }
"

# compile the model
bayesian_PH_model <- stan_model(model_name = "bayesian_PH_model", 
                                         model_code = code_bayesian_PH_model)

# Step 3: Model fitting and summary
niter = 10000; nwarmup = 1000 
bayesian_PH_model_fit <- suppressWarnings(sampling(bayesian_PH_model, data = stan_data4, iter = niter, 
                                    warmup = nwarmup, thin = 10, chain = 1))
#' Summary of the fit
print(summary(bayesian_PH_model_fit)$summary)
```


# 6. Accelerated failure time (AFT) model with covariates
```{r, echo=TRUE}
# Step 1: simulated data generator

# Step 2: Bayesian model setting & compiling

# Step 3: Model fitting and summary
```
